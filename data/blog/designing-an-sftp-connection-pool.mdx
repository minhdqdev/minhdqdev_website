---
title: 'Designing an SFTP Connection Pool That Doesn’t Suck'
date: '2025-02-23'
tags:
  - sftp
  - java
  - integration
  - performance
  - architecture
summary: 'How to think about SFTP connection pooling like a systems engineer, not like a StackOverflow snippet.'
draft: false
---

## 1. Problem setting: when SFTP stops being a footnote

In many enterprise systems, SFTP is “just” an integration detail:

- Push payroll files to a bank.
- Pull batched reports from a partner.
- Synchronize CSVs with some ancient core system.

On paper it’s a simple requirement: “Connect to SFTP and upload N files every hour.”

In practice, the naïve “connect per file” approach gives you:

- Hundreds or thousands of SSH handshakes per batch.
- Latency spikes on every operation due to key exchange and authentication.
- Random “too many connections” or “too many auth failures” from the partner.
- A surprising amount of CPU cost just to open and tear down tunnels.

You end up with an application where **the bottleneck is not business logic, but SSH handshakes**.

This is where an SFTP connection pool stops being an optimization and becomes basic hygiene.

---

## 2. What we actually need from SFTP in a company system

Strip away implementation details and you get a small set of concrete requirements:

- **Throughput**
  Move X files per minute with predictable latency.

- **Stability under load**
  Avoid connection storms when multiple services or threads spike at once.

- **Controlled concurrency**
  Respect limits from the partner: max concurrent sessions, max ops per second.

- **Resilience**
  Survive transient network failures, idle timeouts, and partner restarts without manual intervention.

- **Observability**
  Tell, in numbers, what’s happening: active sessions, failures, retries, handshake time, transfer time.

- **Operational sanity**
  Rotate keys, upgrade libraries, and do maintenance in a controlled way, not via midnight emergencies.

You do not get any of that by sprinkling `new JSch()` calls in random classes.

You get it by treating SFTP like any other expensive shared resource: database connections, HTTP clients, message brokers. That means a **pool**.

---

## 3. Design space: ways to talk to SFTP

Before jumping into “the pool”, it’s useful to map the options.

### 3.1 Option A: Fire-and-forget connections

Pattern:

- For every file or job:
  - Create SSH client.
  - Authenticate.
  - Open SFTP channel.
  - Transfer.
  - Close.

Pros:

- Trivial to implement.
- No shared state, so very low risk of concurrency bugs.

Cons:

- Performance collapses under load.
- You are hostile to the SFTP server (connection storms).
- Latency dominated by handshake, not payload.

This is acceptable for one-off admin scripts, not for services.

### 3.2 Option B: In-process connection pool

Pattern:

- Maintain N open SSH+SFTP sessions per process.
- Workers borrow a session, perform a few operations, then return it.
- Pool manages creation, health, and teardown.

Pros:

- Big reduction in handshake overhead.
- Clear place to enforce concurrency limits and back-pressure.
- Can be implemented as a pure Java component; no extra infra.

Cons:

- More complex than “just open a connection”.
- Requires careful design for thread safety, health checks, and error handling.

This is the default choice for most Java backend services.

### 3.3 Option C: SFTP proxy service

Pattern:

- Build a dedicated SFTP microservice.
- Other services call it via HTTP/queue and never see SFTP directly.
- Proxy owns the pool and encapsulates all complexity.

Pros:

- Centralized configuration and key management.
- Single place for observability and limits.
- Contracts with partners are concentrated in one logical boundary.

Cons:

- Extra deployment and runtime hop.
- You’ve created a critical shared dependency; it must be extremely reliable.
- Overkill if you only have one or two services doing SFTP.

Useful when you have many consumers across the organization, or multiple languages.

For a single Java service or a small set of services, **Option B: in-process pool** is usually the sweet spot. The rest of this post assumes that.

---

## 4. Mental model of an SFTP pool

Conceptually, an SFTP pool is just **resource leasing**.

- There is a finite set of expensive resources (SFTP sessions).
- Workers temporarily lease a resource, use it, and give it back.
- The pool enforces limits and manages lifecycle.

Visualized:

```mermaid
flowchart LR
  subgraph App["Application JVM"]
    W1["Worker 1"]
    W2["Worker 2"]
    W3["Worker 3"]
    Pool["SFTP Connection Pool"]
  end

  W1 -->|borrow()| Pool
  W2 -->|borrow()| Pool
  W3 -->|borrow()| Pool

  subgraph Remote["Partner SFTP Server"]
    SFTP["SSH/SFTP Endpoint"]
  end

  Pool -->|reused sessions| SFTP
```

Key invariants:

- The number of **open sessions** is bounded: `minSize <= current <= maxSize`.
- At any time, a session is either **idle in the pool** or **leased to a worker**, never both.
- Unhealthy sessions are never handed out; they are closed and replaced.

Once you lock these invariants down, the implementation details become easier to reason about.

---

## 5. Java-facing design: how to expose the pool

First define the API you want your application code to see. It should be boring and safe.

### 5.1 Usage from business code

You want something like this at call sites:

```java
try (SftpSession session = sftpPool.borrowSession()) {
    session.upload(localPath, remotePath);
}
```

Characteristics:

- **`SftpSession` implements `AutoCloseable`** so `try-with-resources` guarantees the session is returned even on exceptions.
- Business code never touches JSch / SSHJ / low-level classes directly.
- The pool is injected (e.g. via Spring) and treated like any other infrastructure bean.

### 5.2 Interfaces, not classes

Define interfaces to decouple from a specific library:

```java
public interface SftpSession extends AutoCloseable {
    void upload(Path local, String remotePath);
    InputStream download(String remotePath);
    boolean exists(String remotePath);

    @Override
    void close(); // returns to pool instead of actually closing the SSH connection
}

public interface SftpPool {
    SftpSession borrowSession() throws SftpPoolExhaustedException;
}
```

Internally, you can implement `SftpSession` on top of JSch, SSHJ, or any other library. Externally, business code never cares.

This is not just abstraction for its own sake; it gives you the ability to:

- Swap libraries if one misbehaves or fails security audits.
- Implement a fake/in-memory SFTP for tests.
- Route some calls to a local “sandbox” SFTP in non-prod environments.

---

## 6. Pool internals: how it actually behaves

Implementation details vary, but the mechanics are always similar.

### 6.1 Core data structures

Typical pattern in Java:

- `BlockingQueue<InternalConnection>` for idle sessions.
- Atomic counters for current total sessions.
- Background threads for warm-up and optionally for health-checks.

Where `InternalConnection` wraps:

- The underlying SSH client/channel.
- A timestamp of last use.
- A method like `boolean isHealthy()` and `void closePhysical()`.

### 6.2 Borrow logic (simplified)

Conceptual sequence for `borrowSession()`:

1. Try to take an idle connection from the queue without blocking.
2. If none and `currentSessions < maxSize`, create a new one.
3. If none and `currentSessions >= maxSize`, block on the queue with timeout.
4. When a connection is acquired:
   - Run a cheap health check.
   - If unhealthy, close and decrement counters; then go back to step 1 (retry).

5. Wrap it in an `SftpSession` that, on `close()`, returns the connection to the pool.

Design decisions baked in here:

- **Bounded concurrency**: `maxSize` is enforced by the counter and queue size.
- **Back-pressure**: callers may block when the pool is exhausted.
- **Timeouts**: caller can get a specific exception instead of hanging forever.

### 6.3 Return logic

When `SftpSession.close()` is called:

1. If the underlying connection is unhealthy:
   - Close it physically.
   - Decrement `currentSessions`.

2. Else, offer it back to the idle queue:
   - If the queue is full (e.g. you’ve shrunk `maxSize`), close it physically.

The important mental shift: “closing” a session from the caller’s POV is not the same as closing the SSH connection. You are just changing ownership back to the pool.

---

## 7. Failure modes and how the design absorbs them

Real systems break in specific, repetitive ways. The pool design has to target those.

### 7.1 Idle timeouts from remote

Many SFTP servers kill idle sessions after N minutes.

Without handling:

- First use after a long idle period hits EOF / broken pipe.
- Business code sees random `IOException` and retries using the same dead connection.

With a health check:

- The pool notices the connection is dead before leasing it.
- It closes and replaces the session transparently.
- The worker sees a normal session or, in the worst case, a clear “pool exhausted” error.

Design choice: add a cheap health check (`stat` or `pwd` or list on a small directory) in `borrowSession()` for connections that have been idle longer than a threshold.

### 7.2 Network flaps and partial failures

Consider scenarios:

- Packet loss spikes to 100% for 30 seconds.
- DNS fails for the SFTP host.
- The partner restarts the SFTP service.

The pool should not:

- Thrash and create hundreds of failing connections.
- Block all threads indefinitely.

Typical mitigations:

- Limit creation rate of new connections (e.g. via a simple “cooldown” or circuit breaker).
- Fail fast with a clear exception when connection establishment fails repeatedly.
- Instrument retry logic in business code, **not** hidden in the pool; the pool is deterministic, the caller decides policy.

### 7.3 Pool exhaustion and back-pressure

If you let every thread create sessions freely, you hit the partner’s limit and upset everyone.

With a pool:

- `maxSize` approximates the server’s max session count (or a safe fraction of it).
- When all sessions are in use, extra callers block or timeout.
- That back-pressure cascades upstream:
  - Queues fill.
  - Callers see timeouts.
  - Alerting fires.

This is the intended behavior. It is better to see **explicit saturation** than to silently flood the partner and hope for the best.

### 7.4 Credential rotation

In many companies, SSH keys are rotated periodically.

Issues:

- Long-lived sessions might stick around with old credentials; that’s usually fine, but sometimes policy says “kill all old sessions”.

Design options:

- On rotation event, explicitly call `sftpPool.reset()` which:
  - Closes all idle sessions.
  - Prevents borrowing until new sessions are created with the new keys.

- Shorten max connection lifetime so connections are naturally recycled.

The pool becomes the single place where this policy is implemented.

---

## 8. Non-functional aspects: logging, metrics, and tuning

When you treat SFTP as a first-class dependency, you also instrument it properly.

Essential metrics:

- `sftp_pool_active_sessions`
- `sftp_pool_idle_sessions`
- `sftp_pool_borrow_time_ms` (how long it takes to get a session)
- `sftp_handshake_time_ms`
- `sftp_transfer_time_ms` (distribution by file size)
- Error counts:
  - Handshake failures.
  - Transfer failures.
  - Health check failures.

With these, you can answer questions like:

- Is the pool frequently exhausted? Tune `maxSize` or throughput expectations.
- Is handshake time dominating total latency? Sizing of `minSize` and warm-up.
- Are failures correlated with partner maintenance windows? Adjust retries and scheduling.

For logging:

- Log at INFO for successful connection creation and closure, but not for every file transfer.
- Log at WARN/ERROR when:
  - Borrow time exceeds a high percentile.
  - Health checks fail for many connections in a row.
  - The pool has to force-close many connections.

The goal is not verbose logs, but **high signal** when SFTP stops behaving.

---

## 9. How to introduce a pool into an existing Java system

In a real company codebase, SFTP code already exists. The safe path is incremental.

High-level migration plan:

1. **Abstract current usage**
   - Wrap all existing calls in a thin `SftpClient` interface.
   - Implement it as a trivial “connect per call” adapter.
   - Replace direct library usage with this interface.

2. **Introduce pooled implementation behind the same interface**
   - Implement `PooledSftpClient` using the pool described above.
   - Feature-flag which implementation to use per environment.

3. **Roll out with metrics watching**
   - Enable pooled version in a lower environment.
   - Verify:
     - Connection count at the partner.
     - Throughput and latency graphs.
     - Error profiles.

4. **Tune pool sizes and timeouts based on observed behavior**
   - Start conservative: small `maxSize`, reasonable `borrow` timeouts.
   - Adjust only with actual data.

Migration is not a weekend refactor; it is a controlled change in how your system talks to an external dependency.

---

## 10. Summary

An SFTP connection pool is not about showing off concurrency skills. It is about:

- Treating SSH/SFTP as a scarce, expensive resource.
- Making concurrency and failure modes explicit instead of accidental.
- Giving operations and security a clear, centralized lever for SFTP behavior.

The Java implementation details are just machinery around a few simple ideas:

- Bounded pool.
- Leasing semantics via `AutoCloseable`.
- Health checks and lifecycle management.
- Metrics and logs that reveal behavior instead of hiding it.

Once those ideas are set, the question “how many SFTP sessions should this service have” becomes a configuration problem backed by data, not an argument in a meeting.
